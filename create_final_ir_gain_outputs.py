#! /usr/bin/env python

"""Creates final output for the IR gain wrapper.

Use:
    
    >>> python create_final_ir_gain_outputs.py --a (optional) --n (optional)

    --a : Default of 'true'. If 'true', copies plots to automated_outputs,
          as long as the obstype='flat_long'.
    --n : Default of 'false'. If 'true', creates outputs from the nominal
          settings of filebasenames=['ipc_maskbad'] and obstypes=['flat_long'].
          If 'false', gets values of filebasename and obstype from file
          'finalresults/finalresults_infile.dat'.

Authors:
    
    C.M. Gosmeyer, Jan. 2016

Example:

    Turning off the copy to automated_outputs,

    >>> python create_final_ir_gain_outputs.py --a 'false'

Outputs:

    In location of the 'outputs/final_results/<observation type>/<timestamp_dir>',

    ascii files
        'stats_<file_basename>.dat' 
        'epochgains_<file_basename>.dat'

    PNG plots.
        '<timestamp_dir>/gainVStime_<file_basename>.png'
        '<timestamp_dir>/gainVSindex_<file_basename>.png'    
        'epochgainsVStime_<file_basename>.png'

Notes:

    If select --n 'false'  (default),
    relies on the existance of a file 'finalresults/finalresults_infile.dat'
    that is generated by 'run_ir_gain.pro'.
    This file contains two columns with 'file_basename' and 'obs_type'.
"""

import argparse
import datetime
import glob
import numpy as np 
import os
import pylab
import shutil
import sys
import time

from astropy.io import ascii
from astropy.time import Time
from matplotlib.ticker import MultipleLocator, FormatStrFormatter
from set_paths import path_to_outputs, path_to_automated_outputs
from detector_tools.files.make_timestamp_dir import make_timestamp_dir


#------------------------------------------------------------------------------

def copy_plots_to_automated_outputs(path_to_plots=''):
    """Copies IR gain plots to the 'daily_outputs' directory, so they
    can be displayed on the QL website.

    ONLY works on plots from 'flat_long' (the nominal dataset).
    
    Parameters:
        path_to_plots : string
            Path to the plots you want displayed on the website.
            
    Returns:
        nothing
        
    Outputs:
        nothing
    """

    if 'flat_long' in path_to_plots:
        plots = glob.glob(path_to_plots + '*png')
        print "Plots to be copied to 'daily_ouputs': " 
        print plots
    
        for plot in plots:
            shutil.copy(plot, path_to_automated_outputs)
    else:
        print "These plots are NOT the nominal obs_type='flat_long'."
        print "Therefore the files were not copied to automated_outputs."


#------------------------------------------------------------------------------

def create_gain_vs_plots(gain1, gain2, gain3, gain4, mjd1, mjd2, \
                         timestamp_dir, file_basename):
    """ Plots ALL gains in each quad vs time and vs index. 

    Parameters:
        gain1 : array
            Gains for quadrant 1. 
        gain2 : array
            Gains for quadrant 2. 
        gain3 : array
            Gains for quadrant 3. 
        gain4 : array
            Gains for quadrant 4. 
        mjd1 : array
            MJDs for first ramp of pairs.
        mjd2 : array
            MJDs for second ramp of pairs.
        timestamp_dir : string
            Time-stamped directory in 'outputs/finalresults/<observation type>/'.
            Where the plots will be generated.

    Returns:
        nothing

    Outputs:
        PNG plots.
        '<timestamp_dir>/gainVStime_<file_basename>.png'
        '<timestamp_dir>/gainVSindex_<file_basename>.png'

    """
    # First plot INDEX vs GAIN.
    fig, axarr = pylab.subplots(2, 2, figsize=(14,10))

    axarr[0, 0].scatter(np.arange(len(mjd1)), gain1, s=50, marker='d', \
                        edgecolor='g', facecolor='None', linewidth=2)
    axarr[0, 0].set_title('Gain 1', fontsize=22)
    axarr[0, 0].set_ylabel('Gain [e-/ADU]', fontsize=18)
    axarr[0, 0].set_ylim(1.0, 2.31)
    axarr[0, 0].minorticks_on()

    axarr[1, 0].scatter(np.arange(len(mjd1)), gain2, s=50, marker='d', \
                        edgecolor='g', facecolor='None', linewidth=2)
    axarr[1, 0].set_title('Gain 2', fontsize=22)
    axarr[1, 0].set_ylabel('Gain [e-/ADU]', fontsize=18)
    axarr[1, 0].set_xlabel('Index', fontsize=18)
    axarr[1, 0].set_ylim(1.0, 2.31)
    axarr[1, 0].minorticks_on()

    axarr[1, 1].scatter(np.arange(len(mjd1)), gain3, s=50, marker='d', \
                        edgecolor='g', facecolor='None', linewidth=2)
    axarr[1, 1].set_title('Gain 3', fontsize=22)
    axarr[1, 1].set_xlabel('Index', fontsize=18)
    axarr[1, 1].set_ylim(1.0, 2.31)
    axarr[1, 1].minorticks_on()

    axarr[0, 1].scatter(np.arange(len(mjd1)), gain4, s=50, marker='d', \
                        edgecolor='g', facecolor='None', linewidth=2)
    axarr[0, 1].set_title('Gain 4', fontsize=22)
    axarr[0, 1].set_ylim(1.0, 2.31)
    axarr[0, 1].minorticks_on()

    # Fine-tune figure; hide x ticks for top plots and y ticks for right plots.
    pylab.setp([a.get_xticklabels() for a in axarr[0, :]], visible=False)
    pylab.setp([a.get_yticklabels() for a in axarr[:, 1]], visible=False)

    pylab.savefig(timestamp_dir + 'gainVSindex_' + file_basename + '.png')


    # Second plot MJD vs GAIN.
    fig, axarr = pylab.subplots(2, 2, figsize=(14,10))

    print "MJD1: ", mjd1
    n_labels = 2 #len(mjd1)

    #axarr[0, 0].locator_params(nbins=n_labels) # Set number of x-axis labels
    axarr[0, 0].scatter(mjd1, gain1, s=50, marker='d', edgecolor='r', \
                        facecolor='None', linewidth=2)
    axarr[0, 0].set_title('Gain 1', fontsize=22)
    axarr[0, 0].set_ylabel('Gain [e-/ADU]', fontsize=18)
    axarr[0, 0].set_ylim(1.0, 2.31)
    axarr[0, 0].minorticks_on()
    fig.canvas.draw()
    #time_ymd = convert_mjds_to_dates(axarr[0, 0])
    #axarr[0, 0].set_xticklabels(time_ymd,'', fontsize=14)

    #axarr[1, 0].locator_params(nbins=n_labels) # Set number of x-axis labels
    axarr[1, 0].scatter(mjd1, gain2, s=50, marker='d', edgecolor='r', \
                        facecolor='None', linewidth=2)
    axarr[1, 0].set_title('Gain 2', fontsize=22)
    axarr[1, 0].set_ylabel('Gain [e-/ADU]', fontsize=18)
    axarr[1, 0].set_xlabel('Dates', fontsize=18)
    axarr[1, 0].set_ylim(1.0, 2.31)
    axarr[1, 0].minorticks_on()
    fig.canvas.draw()
    #time_ymd = convert_mjds_to_dates(axarr[1, 0])
    #axarr[1, 0].set_xticklabels(time_ymd,'', fontsize=14)

    #axarr[1, 1].locator_params(nbins=n_labels) # Set number of x-axis labels
    axarr[1, 1].scatter(mjd1, gain3, s=50, marker='d', edgecolor='r', \
                        facecolor='None', linewidth=2)
    axarr[1, 1].set_title('Gain 3', fontsize=22)
    axarr[1, 1].set_xlabel('Dates', fontsize=18)
    axarr[1, 1].set_ylim(1.0, 2.31)
    axarr[1, 1].minorticks_on()
    fig.canvas.draw()
    #time_ymd = convert_mjds_to_dates(axarr[1, 1])
    #axarr[1, 1].set_xticklabels(time_ymd,'', fontsize=14)

    #axarr[0, 1].locator_params(nbins=n_labels) # Set number of x-axis labels
    axarr[0, 1].scatter(mjd1, gain4, s=50, marker='d', edgecolor='r', \
                        facecolor='None', linewidth=2)
    axarr[0, 1].set_title('Gain 4', fontsize=22)
    axarr[0, 1].set_ylim(1.0, 2.31)
    axarr[0, 1].minorticks_on()
    fig.canvas.draw()
    #time_ymd = convert_mjds_to_dates(axarr[0, 1])
    #axarr[0, 1].set_xticklabels(time_ymd,'', fontsize=14)

    # Fine-tune figure; hide x ticks for top plots and y ticks for right plots.
    pylab.setp([a.get_xticklabels() for a in axarr[0, :]], visible=False)
    pylab.setp([a.get_yticklabels() for a in axarr[:, 1]], visible=False)


    pylab.savefig(timestamp_dir + 'gainVStime_' + file_basename + '.png')    


#------------------------------------------------------------------------------

def create_epochgain_vs_time_plots(epoch_gains, mjds, timestamp_dir, \
                                   file_basename):
    """Creates plot of epoch-averaged IR gain vs time for each quadrant.
    Draws lines of standard deviation above and below the epoch-averaged
    gain values.

    Parameters:
        epoch_gains : list of lists
            Average gains for each epoch and the standard deviations.
            [[av1], [av2], [av3], [av4], [stdev1], [stdev2], [stdev3], [stdev4]]
        mjds : list
            Average MJDs (mjd1) for each epoch.
        timestamp_dir : string
            Time-stamped directory in 'outputs/finalresults/<observation type>/'.
            Where the plot will be generated.
        file_basename : string
            Basename of this run of the IR gain suite. ie, 
            'ipc_maskbad'

    Returns:
        nothing

    Outputs:
        PNG plot.
        'epochgainsVStime_<file_basename>.png'

    Notes:
        When plotting proceeed 1-4-2-3. Because IR quad labels are silly.    
    """
    fig, axarr = pylab.subplots(2, 2, figsize=(14,10))

    n_labels = len(mjds)

    # Gain quad 1
    axarr[0, 0].scatter(mjds, epoch_gains[0], s=50, marker='d', edgecolor='b', \
                        facecolor='None', linewidth=2)
    #axarr[0, 0].plot(mjds, np.array(epoch_gains[0]) + np.array(epoch_gains[4]), color='k')  # upper stand dev lines. 
    #axarr[0, 0].plot(mjds, np.array(epoch_gains[0]) - np.array(epoch_gains[4]), color='k')  # lower stand dev lines. 
    #axarr[0, 0].annotate('Standard Dev', xy =(55500, 2.23), color='k')
    axarr[0, 0].set_title('Gain 1', fontsize=22)
    axarr[0, 0].set_ylabel('Gain/Epoch [e-/ADU]', fontsize=18)
    axarr[0, 0].set_ylim(1.0, 2.31)
    axarr[0, 0].minorticks_on()
    # Add dashed horizonal lines at 0.02 intervals.
    for ymaj in np.arange(2.14, 2.4, .02):
        axarr[0, 0].axhline(y=ymaj,linestyle='--',color='grey')
    # Convert MJD axis to ymd dates.
    fig.canvas.draw()
    #time_ymd = convert_mjds_to_dates(axarr[0, 0])
    #axarr[0, 0].set_xticklabels(time_ymd,'', fontsize=14)

    # Gain quad 2
    axarr[1, 0].scatter(mjds, epoch_gains[1], s=50, marker='d', edgecolor='b', \
                        facecolor='None', linewidth=2)
    #axarr[1, 0].plot(mjds, np.array(epoch_gains[1]) + np.array(epoch_gains[5]), color='k')  # upper stand dev lines. 
    #axarr[1, 0].plot(mjds, np.array(epoch_gains[1]) - np.array(epoch_gains[5]), color='k')  # lower stand dev lines. 
    axarr[1, 0].set_title('Gain 2', fontsize=22)
    axarr[1, 0].set_ylabel('Gain/Epoch [e-/ADU]', fontsize=18)
    axarr[1, 0].set_xlabel('Dates', fontsize=18)
    axarr[1, 0].set_ylim(1.0, 2.31)
    axarr[1, 0].minorticks_on()
    # Add dashed horizonal lines at 0.02 intervals.
    for ymaj in np.arange(2.14, 2.4, .02):
        axarr[1, 0].axhline(y=ymaj,linestyle='--',color='grey')
    # Convert MJD axis to ymd dates.
    fig.canvas.draw()
    #time_ymd = convert_mjds_to_dates(axarr[1, 0])
    #axarr[1, 0].set_xticklabels(time_ymd,'Dates', fontsize=14)

    # Gain quad 3
    axarr[1, 1].scatter(mjds, epoch_gains[2], s=50, marker='d', edgecolor='b', \
                        facecolor='None', linewidth=2)
    #axarr[1, 1].plot(mjds, np.array(epoch_gains[2]) + np.array(epoch_gains[6]), color='k')  # upper stand dev lines. 
    #axarr[1, 1].plot(mjds, np.array(epoch_gains[2]) - np.array(epoch_gains[6]), color='k')  # lower stand dev lines. 
    axarr[1, 1].set_title('Gain 3', fontsize=22)
    axarr[1, 1].set_xlabel('Dates', fontsize=18)
    axarr[1, 1].set_ylim(1.0, 2.31)
    axarr[1, 1].minorticks_on()
    # Add dashed horizonal lines at 0.02 intervals.
    for ymaj in np.arange(2.14, 2.4, .02):
        axarr[1, 1].axhline(y=ymaj,linestyle='--',color='grey')
    # Convert MJD axis to ymd dates.
    fig.canvas.draw()
    #time_ymd = convert_mjds_to_dates(axarr[1, 1])
    #axarr[1, 1].set_xticklabels(time_ymd,'Dates', fontsize=14)

    # Gain quad 4
    axarr[0, 1].scatter(mjds, epoch_gains[3], s=50, marker='d', edgecolor='b', \
                        facecolor='None', linewidth=2)
    #axarr[0, 1].plot(mjds, np.array(epoch_gains[3]) + np.array(epoch_gains[7]), color='k')  # upper stand dev lines. 
    #axarr[0, 1].plot(mjds, np.array(epoch_gains[3]) - np.array(epoch_gains[7]), color='k')  # lower stand dev lines. 
    axarr[0, 1].set_title('Gain 4', fontsize=22)
    axarr[0, 1].set_ylim(1.0, 2.31)
    axarr[0, 1].minorticks_on()
    # Add dashed horizonal lines at 0.02 intervals.
    for ymaj in np.arange(2.14, 2.4, .02):
        axarr[0, 1].axhline(y=ymaj,linestyle='--',color='grey')
    # Convert MJD axis to ymd dates.
    fig.canvas.draw()
    #time_ymd = convert_mjds_to_dates(axarr[0, 1])
    #axarr[0, 1].set_xticklabels(time_ymd,'', fontsize=14)

    # Fine-tune figure; hide x ticks for top plots and y ticks for right plots.
    pylab.setp([a.get_xticklabels() for a in axarr[0, :]], visible=False)
    pylab.setp([a.get_yticklabels() for a in axarr[:, 1]], visible=False)

    pylab.savefig(timestamp_dir + 'epochgainsVStime_' + file_basename + '.png')


#------------------------------------------------------------------------------

def convert_mjds_to_dates(ax):
    """Converts MJDs of a list of x tick labels to years.

    Parameters:
        ax : pylab axis object
            The axis containing x tick labels to be converted.

    Returns:
        tick_labels : list
            The year-converted x tick labels.

    Outputs:
        nothing
    """
    # Fetch the mjd axis as list.
    """time_mjd = [(item.get_text()) for item in ax.get_xticklabels()]
    print time_mjd
    # Convert to mjd list to Time object.
    time_convert = Time(time_mjd, format='mjd') #, scale='utc')
    # Convert to year-month-day dates.
    tick_labels = [datetime.datetime.strftime(label.datetime, '%Y')
        for label in time_convert]"""

    #return tick_labels 
    return ax


#------------------------------------------------------------------------------

def get_epoch_gains(gain1, gain2, gain3, gain4, mjd1, mjd2):
    """ Calculates the average 'final' gain for each quad in 
    each epoch and their standard devs. Also calculate average MJD
    of each epoch.

    Parameters:
        gain1 : array
            Gains for quadrant 1. 
        gain2 : array
            Gains for quadrant 2. 
        gain3 : array
            Gains for quadrant 3. 
        gain4 : array
            Gains for quadrant 4. 
        mjd1 : array
            MJDs for first ramp of pairs.
        mjd2 : array
            MJDs for second ramp of pairs.

    Returns:
        epoch_gains : list of lists
            Average gains for each epoch and the standard deviations.
            [[av1], [av2], [av3], [av4], [stdev1], [stdev2], [stdev3], [stdev4]]
        mjds : list
            Average MJDs (mjd1) for each epoch.

    Outputs:
        nothing
    """
    mjds = []
    epoch_gains = [[], [], [], [], [], [], [], []]

    # Initialize gain lists to be reset after each epoch.
    # These lists will be averaged and have standard deviations calculated.
    epoch_gain1 = [gain1[0]]
    epoch_gain2 = [gain2[0]]
    epoch_gain3 = [gain3[0]]
    epoch_gain4 = [gain4[0]]
    epoch_mjd = [mjd1[0]]

    for g in range(1, len(gain1)):
        # Check MJDs. Group epochs based on whether taken more than 30 days from previous.
        # Also check whether at the final iteration.
        if ((float(mjd1[g]) - float(mjd1[g-1])) > 29.) or (g == len(gain1)-1):
            # If ending an epoch, calcaulate the epoch's average gains and 
            # standard deviations, as well as the average mjd.
            gain1_av = np.mean(epoch_gain1) 
            gain1_stddev = np.std(epoch_gain1)
            gain2_av = np.mean(epoch_gain2)
            gain2_stddev = np.std(epoch_gain2)
            gain3_av = np.mean(epoch_gain3) 
            gain3_stddev = np.std(epoch_gain3)
            gain4_av = np.mean(epoch_gain4) 
            gain4_stddev = np.std(epoch_gain4)
            mjd_av = np.mean(epoch_mjd) 

            print "--------"
            print "epoch gain1: ", epoch_gain1
            print "epoch gain2: ", epoch_gain2
            print "epoch gain3: ", epoch_gain3
            print "epoch gain4: ", epoch_gain4

            print "Number of pairs in epoch: ", len(epoch_gain1)
            print "av gain1: ", gain1_av
            print "stddev 1: ", gain1_stddev
            print "av gain2: ", gain2_av
            print "stddev 2: ", gain2_stddev
            print "av gain3: ", gain3_av
            print "stddev 3: ", gain3_stddev
            print "av gain4: ", gain4_av
            print "stddev 4: ", gain4_stddev
            print "av mjd: ", mjd_av
            
            # Append to the final epoch gain lists.
            epoch_gains[0].append(gain1_av)
            epoch_gains[1].append(gain2_av)
            epoch_gains[2].append(gain3_av)
            epoch_gains[3].append(gain4_av)
            epoch_gains[4].append(gain1_stddev)
            epoch_gains[5].append(gain2_stddev)
            epoch_gains[6].append(gain4_stddev)
            epoch_gains[7].append(gain4_stddev)     
            mjds.append(mjd_av)       

            # Reset the lists.
            epoch_gain1 = [gain1[g]]
            epoch_gain2 = [gain2[g]]
            epoch_gain3 = [gain3[g]]
            epoch_gain4 = [gain4[g]]
            epoch_mjd = [mjd1[g]]


        elif (float(mjd2[g]) - float(mjd1[g])) <= 29.:
            # If the MJD - previous MJD is less than 30 then the gains can be grouped.
            epoch_gain1.append(gain1[g])
            epoch_gain2.append(gain2[g])
            epoch_gain3.append(gain3[g])
            epoch_gain4.append(gain4[g])
            epoch_mjd.append(mjd1[g])

    return epoch_gains, mjds


#------------------------------------------------------------------------------

def read_gainlist(loc, gainlist):
    """

    Parameters:
        loc : string
            Location of the gainlist file.

        gainlist : string
            Name of the file containing list of gains and mjds.

    Returns:
        gain1 : array
            Gains for quadrant 1. 
        gain2 : array
            Gains for quadrant 2. 
        gain3 : array
            Gains for quadrant 3. 
        gain4 : array
            Gains for quadrant 4. 
        mjd1 : array
            MJDs for first ramp of pairs.
        mjd2 : array
            MJDs for second ramp of pairs.

    Outputs:
        nothing
    """
    
    if os.path.isfile(loc + gainlist):
        data = ascii.read(loc + gainlist)
        gain1 = data['gain1']
        gain2 = data['gain2']
        gain3 = data['gain3']
        gain4 = data['gain4']

        mjd1 = data['mjd1']
        mjd2 = data['mjd2']

    else: 
        print "Does NOT exist: ", loc + gainlist


    return gain1, gain2, gain3, gain4, mjd1, mjd2


#------------------------------------------------------------------------------

def write_epochgain_file(epoch_gains, mjds, timestamp_dir, file_basename):
    """Writes a file with the epoch averaged gain and standard deviation
    for each epoch. Basically a file of what gets plotted in 
    func:`create_epochgain_vs_time_plots`. 

    Parameters:
        epoch_gains : list of lists
            Average gains for each epoch and the standard deviations.
            [[av1], [av2], [av3], [av4], [stdev1], [stdev2], [stdev3], [stdev4]]
        mjds : list
            Average MJDs (mjd1) for each epoch.
        timestamp_dir : string
            Time-stamped directory in 'outputs/finalresults/<observation type>/'.
            Where the file will be generated.
    
    Returns:
        nothing

    Outputs:
        ascii file.
        'epochgains_<file_basename>.dat'
    """
    av_gain1 = epoch_gains[0]
    av_gain2 = epoch_gains[1]
    av_gain3 = epoch_gains[2]
    av_gain4 = epoch_gains[3]

    stddev1 = epoch_gains[4]
    stddev2 = epoch_gains[5]
    stddev3 = epoch_gains[6]
    stddev4 = epoch_gains[7]

    tt = {'#av_gain1':av_gain1, 'stddev1':stddev1, 'av_gain2':av_gain2, 'stddev2':stddev2, \
          'av_gain3':av_gain3, 'stddev3':stddev3, 'av_gain4':av_gain4, 'stddev4':stddev4}

    ascii.write(tt, timestamp_dir + 'epochgains_' + file_basename + '.dat', 
                 names=['#av_gain1', 'stddev1', 'av_gain2', 'stddev2', \
                 'av_gain3', 'stddev3', 'av_gain4', 'stddev4'])


#------------------------------------------------------------------------------

def write_stats_file(gain1, gain2, gain3, gain4, mjd1, mjd2, timestamp_dir, \
                     file_basename):
    """ Writes a file with the max, min, average, and standard dev of
    ENTIRE set of gains.

    Parameters:
        gain1 : array
            Gains for quadrant 1. 
        gain2 : array
            Gains for quadrant 2. 
        gain3 : array
            Gains for quadrant 3. 
        gain4 : array
            Gains for quadrant 4. 
        mjd1 : array
            MJDs for first ramp of pairs.
        mjd2 : array
            MJDs for second ramp of pairs.
        timestamp_dir : string
            Time-stamped directory in 'outputs/finalresults/<observation type>/'.
            Where the file will be generated.
        file_basename : string
            Basename of this run of the IR gain suite. ie, 'ipc_maskbad'

    Returns:
        nothing

    Outputs:
        ascii file.
        'stats_<file_basename>.dat'
    """
    max_gain1 = np.max(gain1)
    min_gain1 = np.min(gain1)
    av_gain1 = np.mean(gain1)
    stddev_gain1 = np.std(gain1)
    
    max_gain2 = np.max(gain2)
    min_gain2 = np.min(gain2)
    av_gain2 = np.mean(gain2)
    stddev_gain2 = np.std(gain2)

    max_gain3 = np.max(gain3)
    min_gain3 = np.min(gain3)
    av_gain3 = np.mean(gain3)
    stddev_gain3 = np.std(gain3)

    max_gain4 = np.max(gain4)
    min_gain4 = np.min(gain4)
    av_gain4 = np.mean(gain4)
    stddev_gain4 = np.std(gain4)
    
    quads = ['Gain1', 'Gain2', 'Gain3', 'Gain4']
    maxes = [max_gain1, max_gain2, max_gain3, max_gain4]
    mins = [min_gain1, min_gain2, min_gain3, min_gain4]
    averages = [av_gain1, av_gain2, av_gain3, av_gain4]
    stddevs = [stddev_gain1, stddev_gain2, stddev_gain3, stddev_gain4]


    tt = {'#quad':quads, 'max':maxes, 'min':mins, 'average':averages, 'stddev':stddevs}

    ascii.write(tt, timestamp_dir + 'stats_' + file_basename + '.dat', 
                 names=['#quad', 'max', 'min', 'average', 'stddev'])


#------------------------------------------------------------------------------
# The main controller.
#------------------------------------------------------------------------------

def create_final_ir_gain_outputs(nominal=False, copy_to_ao = False):
    """ Main wrapper function.

    Parameters:
        nominal : {True, False}
            Set to True if do NOT want to obtain 'file_basenames' and
            'obs_types' from file 'finalresults/finalresults_infile.dat'.
            Will default to filebasenames=['ipc_maskbad'] and
            obstypes=['flat_long'].
        copy_to_ao : {True, False}
            Set to True to copy plots to automated_outputs.
    Returns:
        nothing

    Outputs:
        see :func:`write_stats_file`, :func:`write_epochgain_file`,
        :func:`create_epochgain_vs_time_plots`, and 
        :func:`create_gain_vs_plots`

    Notes:
        If nominal set to False (default),
        relies on the existance of a file 'finalresults/finalresults_infile.dat'
        that is generated by 'run_ir_gain.pro'.
        This file contains two columns with 'file_basename' and 'obs_type'.
    """
    
    if nominal:
        file_basename_ls = ['ipc_maskbad']
        obs_type_ls = ['flat_long']

    else: 
        # Read in the file of lists of file_basename and obs_type.
        # that was created by run_ir_gain.pro in scripts directory.
        file_basename_ls = []
        obs_type_ls = []

        with open(path_to_outputs + 'finalresults/finalresults_infile.dat', 'r') as f:
            line = f.readline()
            print "line: ", line
            line_split = line.split(' ')
            print "line_split", line_split
            tick = 0
            for item in line_split:
                if (item != '') and (tick == 0):
                    file_basename_ls.append(item)
                    tick = 1
                elif (item != '') and (tick == 1):
                    obs_type_ls.append(item.split('\n')[0])

    print file_basename_ls
    print obs_type_ls

    for file_basename, obs_type in zip(file_basename_ls, obs_type_ls):
        # If obs_type starts with an underscore, remove.
        if obs_type[0] == '_':
            obs_type = obs_type[1:len(obs_type)]

        print "..Looping over file_basename '{0}'' and obstype '{1}'"\
               .format(file_basename, obs_type)
        print " "

        # String together the path to intermediates directory.
        
        path_to_inter = path_to_outputs + 'intermediates/' + obs_type + '/'
        print "path_to_inter: ", path_to_inter
        gainlist = 'gainlist_' + file_basename  + '.dat'
        print "gainlist: ", gainlist
        
        # Generate the timestamp directory in finalresults/<obs_type>
        timestamp_dir = make_timestamp_dir(dest=path_to_outputs + \
                       'finalresults/' + obs_type + '/')
        print "timestamp_dir: ", timestamp_dir
        print " "

        # Read in the gain values.
        print '..Reading gain values from ', path_to_inter + gainlist
        print " "
        gain1, gain2, gain3, gain4, mjd1, mjd2 = read_gainlist(loc=path_to_inter, \
                                                               gainlist=gainlist)

        # Write the overall max, min, etc. gains into a file in timestamp directory.
        print "..Writing stats file to ", timestamp_dir + 'stats_' + \
              file_basename + '.dat'
        print " "
        write_stats_file(gain1=gain1, gain2=gain2, gain3=gain3, \
                         gain4=gain4, mjd1=mjd1, mjd2=mjd2, \
                         timestamp_dir=timestamp_dir, \
                         file_basename=file_basename)

        # Create plots of all gains vs time and index. 
        print "..Creating plot ", timestamp_dir + 'gainVSindex_' + \
              file_basename + '.png'
        print "..Creating plot ", timestamp_dir + 'gainVStime_' + \
              file_basename + '.png'
        print " "
        create_gain_vs_plots(gain1=gain1, gain2=gain2, \
                             gain3=gain3, gain4=gain4, \
                             mjd1=list(mjd1), mjd2=list(mjd2), \
                             timestamp_dir=timestamp_dir, \
                             file_basename=file_basename)

        # Average the gains for each epoch
        print "..Calculating the gains per 6-month epoch."
        print " "
        epoch_gains, mjds = get_epoch_gains(gain1=gain1, gain2=gain2, \
                                            gain3=gain3, gain4=gain4, \
                                            mjd1=mjd1, mjd2=mjd2)

        # Write the epoch gains and their standard devs into a file.
        print "..Writing the epoch gains to ", timestamp_dir + \
              'epochgains_' + file_basename + '.dat'
        print " "
        write_epochgain_file(epoch_gains=epoch_gains, mjds=mjds, \
                             timestamp_dir=timestamp_dir, \
                             file_basename=file_basename)

        # Create the plots of epoch gain vs time.
        print "..Creating epoch gains vs time plot " + timestamp_dir + \
              'epochgainsVStime_' + file_basename + '.png'
        print " "
        create_epochgain_vs_time_plots(epoch_gains=epoch_gains, \
                                       mjds=mjds, \
                                       timestamp_dir=timestamp_dir, \
                                       file_basename=file_basename)

        # Copy to automated_outputs/ir_gain/daily_outputs/
        if copy_to_ao:
            print "...Copying plots to automated_outputs/ir_gain/daily_outputs"
            copy_plots_to_automated_outputs(path_to_plots=timestamp_dir)


#-------------------------------------------------------------------------------  

def parse_args():
    """Parses command line arguments.
    
    Parameters:
        nothing
        
    Returns:
        args : object
            Containing the image and destination arguments.
            
    Outputs:
        nothing.
    """

    n_help = "Do you want to run in nominal mode (ipc_maskbad, flat_long)? true/false. False by default."
    a_help = "Do you want any 'flat_long' plots to be copied to automated_outputs? true/false. True by default."
        
    parser = argparse.ArgumentParser()
    parser.add_argument('--n', dest = 'nominal',
                        action = 'store', type = str, required = False,
                        help = n_help, default='false')
    parser.add_argument('--a', dest = 'copy_to_ao',
                        action = 'store', type = str, required = False,
                        help = a_help, default='true')              
    args = parser.parse_args()
     
    return args


#-------------------------------------------------------------------------------   

def change_to_bool(var):
    """Change input to a boolean.

    Parameters:
        var : string
            Either 'true', 'false', 't', or 'f'. Upper of lower does not 
            matter.

    Returns:
        var_bool : boolean
            The boolean value corresponding to 'var'.

    Outputs:
        nothing
    """
    var = var.lower()
    if var == 'true' or var == 't':
        var_bool = True
    elif var == 'false' or var == 'f':
        var_bool = False
    return var_bool

#-------------------------------------------------------------------------------#    


if __name__=='__main__':
    args = parse_args()

    # Return any user input.
    nominal = args.nominal
    copy_to_ao = args.copy_to_ao

    # Change to booleans.
    copy_to_ao = change_to_bool(copy_to_ao)
    nominal = change_to_bool(nominal)

    # Call the primary function.
    create_final_ir_gain_outputs(nominal=nominal, copy_to_ao=copy_to_ao)


